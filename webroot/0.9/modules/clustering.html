

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>4.3. Clustering &mdash; scikit-learn 0.9 documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.9',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="top" title="scikit-learn 0.9 documentation" href="../index.html" />
    <link rel="up" title="4. Unsupervised learning" href="../unsupervised_learning.html" />
    <link rel="next" title="4.4. Decomposing signals in components (matrix factorization problems)" href="decomposition.html" />
    <link rel="prev" title="4.2. Manifold learning" href="manifold.html" />
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-22606712-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
          <p class="logo"><a href="../index.html">
            <img src="../_static/scikit-learn-logo-small.png" alt="Logo"/>
          </a>
          </p><div class="navbar">
          <ul>
            <li><a href="../install.html">Download</a></li>
            <li><a href="../support.html">Support</a></li>
            <li><a href="../user_guide.html">User Guide</a></li>
            <li><a href="../auto_examples/index.html">Examples</a></li>
            <li><a href="../developers/index.html">Development</a></li>
       </ul>

<div class="search_form">

<div id="cse" style="width: 100%;"></div>
<script src="http://www.google.com/jsapi" type="text/javascript"></script>
<script type="text/javascript">
  google.load('search', '1', {language : 'en'});
  google.setOnLoadCallback(function() {
    var customSearchControl = new google.search.CustomSearchControl('016639176250731907682:tjtqbvtvij0');
    customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET);
    var options = new google.search.DrawOptions();
    options.setAutoComplete(true);
    customSearchControl.draw('cse', options);
  }, true);
</script>

</div>

          </div> <!-- end navbar --></div>
    </div>

    <div class="content-wrapper">

    <!-- <div id="blue_tile"></div> -->

        <div class="sphinxsidebar">
        <div class="rel">
          <a href="manifold.html" title="4.2. Manifold learning"
             accesskey="P">previous</a> |
          <a href="decomposition.html" title="4.4. Decomposing signals in components (matrix factorization problems)"
             accesskey="N">next</a> |
          <a href="../np-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
        

        <h3>This page</h3>
         <ul>
<li><a class="reference internal" href="#">4.3. Clustering</a><ul>
<li><a class="reference internal" href="#k-means">4.3.1. K-means</a><ul>
<li><a class="reference internal" href="#mini-batch-k-means">4.3.1.1. Mini Batch K-Means</a></li>
</ul>
</li>
<li><a class="reference internal" href="#affinity-propagation">4.3.2. Affinity propagation</a></li>
<li><a class="reference internal" href="#mean-shift">4.3.3. Mean Shift</a></li>
<li><a class="reference internal" href="#spectral-clustering">4.3.4. Spectral clustering</a></li>
<li><a class="reference internal" href="#hierarchical-clustering">4.3.5. Hierarchical clustering</a><ul>
<li><a class="reference internal" href="#adding-connectivity-constraints">4.3.5.1. Adding connectivity constraints</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dbscan">4.3.6. DBSCAN</a></li>
<li><a class="reference internal" href="#clustering-performance-evaluation">4.3.7. Clustering performance evaluation</a><ul>
<li><a class="reference internal" href="#inertia">4.3.7.1. Inertia</a><ul>
<li><a class="reference internal" href="#presentation-and-usage">4.3.7.1.1. Presentation and usage</a></li>
<li><a class="reference internal" href="#advantages">4.3.7.1.2. Advantages</a></li>
<li><a class="reference internal" href="#drawbacks">4.3.7.1.3. Drawbacks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ajusted-rand-index">4.3.7.2. Ajusted Rand index</a><ul>
<li><a class="reference internal" href="#id5">4.3.7.2.1. Presentation and usage</a></li>
<li><a class="reference internal" href="#id6">4.3.7.2.2. Advantages</a></li>
<li><a class="reference internal" href="#id7">4.3.7.2.3. Drawbacks</a></li>
<li><a class="reference internal" href="#mathematical-formulation">4.3.7.2.4. Mathematical formulation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#homogeneity-completeness-and-v-measure">4.3.7.3. Homogeneity, completeness and V-measure</a><ul>
<li><a class="reference internal" href="#id8">4.3.7.3.1. Presentation and usage</a></li>
<li><a class="reference internal" href="#id9">4.3.7.3.2. Advantages</a></li>
<li><a class="reference internal" href="#id10">4.3.7.3.3. Drawbacks</a></li>
<li><a class="reference internal" href="#id11">4.3.7.3.4. Mathematical formulation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


        

        <h3>Citing</h3>
        <p>Please consider
	<a href="about.html#citing-the-scikit-learn">citing the
	scikit-learn</a>.
        </div>

      <div class="content">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="clustering">
<span id="id1"></span><h1>4.3. Clustering<a class="headerlink" href="#clustering" title="Permalink to this headline">Â¶</a></h1>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Cluster_analysis">Clustering</a> of
unlabeled data can be performed with the module <a class="reference internal" href="classes.html#module-sklearn.cluster" title="sklearn.cluster"><tt class="xref py py-mod docutils literal"><span class="pre">sklearn.cluster</span></tt></a>.</p>
<p>Each clustering algorithm comes in two variants: a class, that implements
the <cite>fit</cite> method to learn the clusters on train data, and a function,
that, given train data, returns an array of integer labels corresponding
to the different clusters. For the class, the labels over the training
data can be found in the <cite>labels_</cite> attribute.</p>
<div class="topic">
<p class="topic-title first">Input data</p>
<p>One important thing to note is that the algorithms implemented in
this module take different kinds of matrix as input.  On one hand,
<a class="reference internal" href="generated/sklearn.cluster.MeanShift.html#sklearn.cluster.MeanShift" title="sklearn.cluster.MeanShift"><tt class="xref py py-class docutils literal"><span class="pre">MeanShift</span></tt></a> and <a class="reference internal" href="generated/sklearn.cluster.KMeans.html#sklearn.cluster.KMeans" title="sklearn.cluster.KMeans"><tt class="xref py py-class docutils literal"><span class="pre">KMeans</span></tt></a> take data matrices of shape
[n_samples, n_features]. These can be obtained from the classes in
the <a class="reference internal" href="classes.html#module-sklearn.feature_extraction" title="sklearn.feature_extraction"><tt class="xref py py-mod docutils literal"><span class="pre">sklearn.feature_extraction</span></tt></a> module. On the other hand,
<a class="reference internal" href="generated/sklearn.cluster.AffinityPropagation.html#sklearn.cluster.AffinityPropagation" title="sklearn.cluster.AffinityPropagation"><tt class="xref py py-class docutils literal"><span class="pre">AffinityPropagation</span></tt></a> and <a class="reference internal" href="generated/sklearn.cluster.SpectralClustering.html#sklearn.cluster.SpectralClustering" title="sklearn.cluster.SpectralClustering"><tt class="xref py py-class docutils literal"><span class="pre">SpectralClustering</span></tt></a> take
similarity matrices of shape [n_samples, n_samples].  These can be
obtained from the functions in the <a class="reference internal" href="classes.html#module-sklearn.metrics.pairwise" title="sklearn.metrics.pairwise"><tt class="xref py py-mod docutils literal"><span class="pre">sklearn.metrics.pairwise</span></tt></a>
module. In other words, <a class="reference internal" href="generated/sklearn.cluster.MeanShift.html#sklearn.cluster.MeanShift" title="sklearn.cluster.MeanShift"><tt class="xref py py-class docutils literal"><span class="pre">MeanShift</span></tt></a> and <a class="reference internal" href="generated/sklearn.cluster.KMeans.html#sklearn.cluster.KMeans" title="sklearn.cluster.KMeans"><tt class="xref py py-class docutils literal"><span class="pre">KMeans</span></tt></a> work
with points in a vector space, whereas <a class="reference internal" href="generated/sklearn.cluster.AffinityPropagation.html#sklearn.cluster.AffinityPropagation" title="sklearn.cluster.AffinityPropagation"><tt class="xref py py-class docutils literal"><span class="pre">AffinityPropagation</span></tt></a>
and <a class="reference internal" href="generated/sklearn.cluster.SpectralClustering.html#sklearn.cluster.SpectralClustering" title="sklearn.cluster.SpectralClustering"><tt class="xref py py-class docutils literal"><span class="pre">SpectralClustering</span></tt></a> can work with arbitrary objects, as
long as a similarity measure exists for such objects.</p>
</div>
<div class="section" id="k-means">
<span id="id2"></span><h2>4.3.1. K-means<a class="headerlink" href="#k-means" title="Permalink to this headline">Â¶</a></h2>
<p>The <a class="reference internal" href="generated/sklearn.cluster.KMeans.html#sklearn.cluster.KMeans" title="sklearn.cluster.KMeans"><tt class="xref py py-class docutils literal"><span class="pre">KMeans</span></tt></a> algorithm clusters data by trying to separate samples
in n groups of equal variance, minimizing a criterion known as the
&#8216;inertia&#8217; of the groups. This algorithm requires the number of cluster to
be specified. It scales well to large number of samples, however its
results may be dependent on an initialisation. As a result, the computation is
often done several times, with different initialisation of the centroids.</p>
<p>K-means is often referred to as Lloyd&#8217;s algorithm. After initialization,
k-means consists of looping between two major steps. First the Voronoi diagram
of the points is calculated using the current centroids. Each segment in the
Voronoi diagram becomes a separate cluster. Secondly, the centroids are updated
to the mean of each segment. The algorithm then repeats this until a stopping
criteria is fulfilled. Usually, as in this implementation, the algorithm
stops when the relative increment in the results between iterations is less than
the given tolerance value.</p>
<p>K-means can be used for vector quantization. This is achieved using the
transform method of a trained model of <a class="reference internal" href="generated/sklearn.cluster.KMeans.html#sklearn.cluster.KMeans" title="sklearn.cluster.KMeans"><tt class="xref py py-class docutils literal"><span class="pre">KMeans</span></tt></a>.</p>
<div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_kmeans_digits.html#example-cluster-plot-kmeans-digits-py"><em>A demo of K-Means clustering on the handwritten digits data</em></a>: Clustering handwritten digits</li>
</ul>
</div>
<div class="section" id="mini-batch-k-means">
<span id="mini-batch-kmeans"></span><h3>4.3.1.1. Mini Batch K-Means<a class="headerlink" href="#mini-batch-k-means" title="Permalink to this headline">Â¶</a></h3>
<p>The <a class="reference internal" href="generated/sklearn.cluster.MiniBatchKMeans.html#sklearn.cluster.MiniBatchKMeans" title="sklearn.cluster.MiniBatchKMeans"><tt class="xref py py-class docutils literal"><span class="pre">MiniBatchKMeans</span></tt></a> is a variant of the <tt class="xref py py-class docutils literal"><span class="pre">K-Means</span></tt> algorithm
using mini-batches, random subset of the dataset, to compute the centroids.</p>
<p>Althought the <a class="reference internal" href="generated/sklearn.cluster.MiniBatchKMeans.html#sklearn.cluster.MiniBatchKMeans" title="sklearn.cluster.MiniBatchKMeans"><tt class="xref py py-class docutils literal"><span class="pre">MiniBatchKMeans</span></tt></a> converge faster than the KMeans
version, the quality of the results, measured by the inertia, the sum of
the distance of each points to the nearest centroid, is not as good as
the <a class="reference internal" href="generated/sklearn.cluster.KMeans.html#sklearn.cluster.KMeans" title="sklearn.cluster.KMeans"><tt class="xref py py-class docutils literal"><span class="pre">KMeans</span></tt></a> algorithm.</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/cluster/plot_mini_batch_kmeans.html"><img alt="../_images/plot_mini_batch_kmeans_11.png" src="../_images/plot_mini_batch_kmeans_11.png" style="width: 800.0px; height: 600.0px;" /></a>
</div>
<div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_mini_batch_kmeans.html#example-cluster-plot-mini-batch-kmeans-py"><em>A demo of the K Means clustering algorithm</em></a>: Comparison of KMeans and
MiniBatchKMeans</li>
<li><a class="reference internal" href="../auto_examples/document_clustering.html#example-document-clustering-py"><em>Clustering text documents using MiniBatchKmeans</em></a>: Document clustering using sparse
MiniBatchKMeans</li>
</ul>
</div>
<div class="topic">
<p class="topic-title first">References:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.eecs.tufts.edu/~dsculley/papers/fastkmeans.pdf">&#8220;Web Scale K-Means clustering&#8221;</a>
D. Sculley, <em>Proceedings of the 19th international conference on World
wide web</em> (2010)</li>
</ul>
</div>
</div>
</div>
<div class="section" id="affinity-propagation">
<h2>4.3.2. Affinity propagation<a class="headerlink" href="#affinity-propagation" title="Permalink to this headline">Â¶</a></h2>
<p><a class="reference internal" href="generated/sklearn.cluster.AffinityPropagation.html#sklearn.cluster.AffinityPropagation" title="sklearn.cluster.AffinityPropagation"><tt class="xref py py-class docutils literal"><span class="pre">AffinityPropagation</span></tt></a> clusters data by diffusion in the similarity
matrix. This algorithm automatically sets its numbers of cluster. It
will have difficulties scaling to thousands of samples.</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/cluster/plot_affinity_propagation.html"><img alt="../_images/plot_affinity_propagation_11.png" src="../_images/plot_affinity_propagation_11.png" style="width: 400.0px; height: 300.0px;" /></a>
</div>
<div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_affinity_propagation.html#example-cluster-plot-affinity-propagation-py"><em>Demo of affinity propagation clustering algorithm</em></a>: Affinity
Propagation on a synthetic 2D datasets with 3 classes.</li>
<li><a class="reference internal" href="../auto_examples/applications/stock_market.html#example-applications-stock-market-py"><em>Finding structure in the stock market</em></a> Affinity Propagation on
Financial time series to find groups of companies</li>
</ul>
</div>
</div>
<div class="section" id="mean-shift">
<h2>4.3.3. Mean Shift<a class="headerlink" href="#mean-shift" title="Permalink to this headline">Â¶</a></h2>
<p><a class="reference internal" href="generated/sklearn.cluster.MeanShift.html#sklearn.cluster.MeanShift" title="sklearn.cluster.MeanShift"><tt class="xref py py-class docutils literal"><span class="pre">MeanShift</span></tt></a> clusters data by estimating <em>blobs</em> in a smooth
density of points matrix. This algorithm automatically sets its numbers
of cluster. It will have difficulties scaling to thousands of samples.</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/cluster/plot_mean_shift.html"><img alt="../_images/plot_mean_shift_11.png" src="../_images/plot_mean_shift_11.png" style="width: 400.0px; height: 300.0px;" /></a>
</div>
<div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_mean_shift.html#example-cluster-plot-mean-shift-py"><em>A demo of the mean-shift clustering algorithm</em></a>: Mean Shift clustering
on a synthetic 2D datasets with 3 classes.</li>
</ul>
</div>
</div>
<div class="section" id="spectral-clustering">
<h2>4.3.4. Spectral clustering<a class="headerlink" href="#spectral-clustering" title="Permalink to this headline">Â¶</a></h2>
<p><a class="reference internal" href="generated/sklearn.cluster.SpectralClustering.html#sklearn.cluster.SpectralClustering" title="sklearn.cluster.SpectralClustering"><tt class="xref py py-class docutils literal"><span class="pre">SpectralClustering</span></tt></a> does a low-dimension embedding of the
affinity matrix between samples, followed by a KMeans in the low
dimensional space. It is especially efficient if the affinity matrix is
sparse and the <a class="reference external" href="http://code.google.com/p/pyamg/">pyamg</a> module is
installed. SpectralClustering requires the number of clusters to be
specified. It works well for a small number of clusters but is not
advised when using many clusters.</p>
<p>For two clusters, it solves a convex relaxation of the <a class="reference external" href="http://www.cs.berkeley.edu/~malik/papers/SM-ncut.pdf">normalised
cuts</a> problem on
the similarity graph: cutting the graph in two so that the weight of the
edges cut is small compared to the weights in of edges inside each
cluster. This criteria is especially interesting when working on images:
graph vertices are pixels, and edges of the similarity graph are a
function of the gradient of the image.</p>
<p class="centered">
<strong><a class="reference external image-reference" href="../auto_examples/cluster/plot_segmentation_toy.html"><img alt="noisy_img" src="../_images/plot_segmentation_toy_11.png" style="width: 300.0px; height: 300.0px;" /></a>
 <a class="reference external image-reference" href="../auto_examples/cluster/plot_segmentation_toy.html"><img alt="segmented_img" src="../_images/plot_segmentation_toy_21.png" style="width: 300.0px; height: 300.0px;" /></a>
</strong></p><div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_segmentation_toy.html#example-cluster-plot-segmentation-toy-py"><em>Spectral clustering for image segmentation</em></a>: Segmenting objects
from a noisy background using spectral clustering.</li>
<li><a class="reference internal" href="../auto_examples/cluster/plot_lena_segmentation.html#example-cluster-plot-lena-segmentation-py"><em>Segmenting the picture of Lena in regions</em></a>: Spectral clustering
to split the image of lena in regions.</li>
</ul>
</div>
<div class="topic">
<p class="topic-title first">References:</p>
<ul class="simple">
<li><a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.165.9323">&#8220;A Tutorial on Spectral Clustering&#8221;</a>
Ulrike von Luxburg, 2007</li>
<li><a class="reference external" href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.160.2324">&#8220;Normalized cuts and image segmentation&#8221;</a>
Jianbo Shi, Jitendra Malik, 2000</li>
<li><a class="reference external" href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.33.1501">&#8220;A Random Walks View of Spectral Segmentation&#8221;</a>
Marina Meila, Jianbo Shi, 2001</li>
<li><a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.8100">&#8220;On Spectral Clustering: Analysis and an algorithm&#8221;</a>
Andrew Y. Ng, Michael I. Jordan, Yair Weiss, 2001</li>
</ul>
</div>
</div>
<div class="section" id="hierarchical-clustering">
<span id="id3"></span><h2>4.3.5. Hierarchical clustering<a class="headerlink" href="#hierarchical-clustering" title="Permalink to this headline">Â¶</a></h2>
<p>Hierarchical clustering is a general family of clustering algorithms that
build nested clusters by merging them successively. This hierarchy of
clusters represented as a tree (or dendrogram). The root of the tree is
the unique cluster that gathers all the samples, the leaves being the
clusters with only one sample. See the <a class="reference external" href="http://en.wikipedia.org/wiki/Hierarchical_clustering">Wikipedia page</a> for more
details.</p>
<p>The <a class="reference internal" href="generated/sklearn.cluster.Ward.html#sklearn.cluster.Ward" title="sklearn.cluster.Ward"><tt class="xref py py-class docutils literal"><span class="pre">Ward</span></tt></a> object performs a hierarchical clustering based on
the Ward algorithm, that is a variance-minimizing approach. At each
step, it minimizes the sum of squared differences within all clusters
(inertia criterion).</p>
<p>This algorithm can scale to large number of samples when it is used jointly
with an connectivity matrix, but can be computationally expensive when no
connectivity constraints are added between samples: it considers at each step
all the possible merges.</p>
<div class="section" id="adding-connectivity-constraints">
<h3>4.3.5.1. Adding connectivity constraints<a class="headerlink" href="#adding-connectivity-constraints" title="Permalink to this headline">Â¶</a></h3>
<p>An interesting aspect of the <a class="reference internal" href="generated/sklearn.cluster.Ward.html#sklearn.cluster.Ward" title="sklearn.cluster.Ward"><tt class="xref py py-class docutils literal"><span class="pre">Ward</span></tt></a> object is that connectivity
constraints can be added to this algorithm (only adjacent clusters can be
merged together), through an connectivity matrix that defines for each
sample the neighboring samples following a given structure of the data. For
instance, in the swiss-roll example below, the connectivity constraints
forbid the merging of points that are not adjacent on the swiss roll, and
thus avoid forming clusters that extend across overlapping folds of the
roll.</p>
<p class="centered">
<strong><a class="reference external image-reference" href="../auto_examples/cluster/plot_ward_structured_vs_unstructured.html"><img alt="unstructured" src="../_images/plot_ward_structured_vs_unstructured_11.png" style="width: 400.0px; height: 300.0px;" /></a>
 <a class="reference external image-reference" href="../auto_examples/cluster/plot_ward_structured_vs_unstructured.html"><img alt="structured" src="../_images/plot_ward_structured_vs_unstructured_21.png" style="width: 400.0px; height: 300.0px;" /></a>
</strong></p><p>The connectivity constraints are imposed via an connectivity matrix: a
scipy sparse matrix that has elements only at the intersection of a row
and a column with indices of the dataset that should be connected. This
matrix can be constructed from apriori information, for instance if you
whish to cluster web pages, but only merging pages with a link pointing
from one to another. It can also be learned from the data, for instance
using <a class="reference internal" href="generated/sklearn.neighbors.kneighbors_graph.html#sklearn.neighbors.kneighbors_graph" title="sklearn.neighbors.kneighbors_graph"><tt class="xref py py-func docutils literal"><span class="pre">sklearn.neighbors.kneighbors_graph</span></tt></a> to restrict
merging to nearest neighbors as in the <a class="reference internal" href="../auto_examples/cluster/plot_ward_structured_vs_unstructured.html#example-cluster-plot-ward-structured-vs-unstructured-py"><em>swiss roll</em></a> example, or
using <a class="reference internal" href="generated/sklearn.feature_extraction.image.grid_to_graph.html#sklearn.feature_extraction.image.grid_to_graph" title="sklearn.feature_extraction.image.grid_to_graph"><tt class="xref py py-func docutils literal"><span class="pre">sklearn.feature_extraction.image.grid_to_graph</span></tt></a> to
enable only merging of neighboring pixels on an image, as in the
<a class="reference internal" href="../auto_examples/cluster/plot_lena_ward_segmentation.html#example-cluster-plot-lena-ward-segmentation-py"><em>Lena</em></a> example.</p>
<div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_lena_ward_segmentation.html#example-cluster-plot-lena-ward-segmentation-py"><em>A demo of structured Ward hierarchical clustering on Lena image</em></a>: Ward clustering
to split the image of lena in regions.</li>
<li><a class="reference internal" href="../auto_examples/cluster/plot_ward_structured_vs_unstructured.html#example-cluster-plot-ward-structured-vs-unstructured-py"><em>Hierarchical clustering: structured vs unstructured ward</em></a>: Example of
Ward algorithm on a swiss-roll, comparison of structured approaches
versus unstructured approaches.</li>
<li><a class="reference internal" href="../auto_examples/cluster/plot_feature_agglomeration_vs_univariate_selection.html#example-cluster-plot-feature-agglomeration-vs-univariate-selection-py"><em>Feature agglomeration vs. univariate selection</em></a>:
Example of dimensionality reduction with feature agglomeration based on
Ward hierarchical clustering.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="dbscan">
<span id="id4"></span><h2>4.3.6. DBSCAN<a class="headerlink" href="#dbscan" title="Permalink to this headline">Â¶</a></h2>
<p>The <tt class="xref py py-class docutils literal"><span class="pre">DBSCAN</span></tt> algorithm clusters data by finding core points which have
many neighbours within a given radius. After a core point is found, the cluster
is expanded by adding its neighbours to the current cluster and recusively
checking if any are core points. Formally, a point is considered a core point
if it has more than min_points points which are of a similarity greater than
the given threshold eps. This is shown in the figure below, where the color
indicates cluster membership and large circles indicate core points found by
the algorithm. Moreover, the algorithm can detect outliers, indicated by black
points below.</p>
<p class="centered">
<strong><a class="reference external image-reference" href="../auto_examples/cluster/plot_dbscan.html"><img alt="dbscan_results" src="../_images/plot_dbscan_11.png" style="width: 400.0px; height: 300.0px;" /></a>
</strong></p><div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_dbscan.html#example-cluster-plot-dbscan-py"><em>Demo of DBSCAN clustering algorithm</em></a>: Clustering synthetic data with DBSCAN</li>
</ul>
</div>
<div class="topic">
<p class="topic-title first">References:</p>
<ul class="simple">
<li>&#8220;A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases
with Noise&#8221;
Ester, M., H. P. Kriegel, J. Sander, and X. Xu,
In Proceedings of the 2nd International Conference on Knowledge Discovery
and Data Mining, Portland, OR, AAAI Press, pp. 226â231. 1996</li>
</ul>
</div>
</div>
<div class="section" id="clustering-performance-evaluation">
<h2>4.3.7. Clustering performance evaluation<a class="headerlink" href="#clustering-performance-evaluation" title="Permalink to this headline">Â¶</a></h2>
<p>Evaluating the performance of a clustering algorithm is not as trivial as
counting the number of errors or the precision and recall of a supervised
classification algorithm. In particular any evaluation metric should not
take the absolute values of the cluster labels into account but rather
if this clustering define separations of the data similar to some ground
truth set of classes or satisfying some assumption such that members
belong to the same class are more similar that members of different
classes according to some similarity metric.</p>
<div class="section" id="inertia">
<h3>4.3.7.1. Inertia<a class="headerlink" href="#inertia" title="Permalink to this headline">Â¶</a></h3>
<div class="section" id="presentation-and-usage">
<h4>4.3.7.1.1. Presentation and usage<a class="headerlink" href="#presentation-and-usage" title="Permalink to this headline">Â¶</a></h4>
<p>TODO: factorize inertia computation out of kmeans and then write me!</p>
</div>
<div class="section" id="advantages">
<h4>4.3.7.1.2. Advantages<a class="headerlink" href="#advantages" title="Permalink to this headline">Â¶</a></h4>
<ul class="simple">
<li>No need for the ground truth knowledge of the &#8220;real&#8221; classes.</li>
</ul>
</div>
<div class="section" id="drawbacks">
<h4>4.3.7.1.3. Drawbacks<a class="headerlink" href="#drawbacks" title="Permalink to this headline">Â¶</a></h4>
<ul class="simple">
<li>Inertia makes the assumption that clusters are convex and isotropic
which is not always the case especially of the clusters are manifolds
with weird shapes: for instance inertia is a useless metrics to evaluate
clustering algorithm that tries to identify nested circles on a 2D plane.</li>
<li>Inertia is not a normalized metrics: we just know that lower values are
better and bounded by zero. One potential solution would be to adjust
inertia for random clustering (assuming the number of ground truth classes
is known).</li>
</ul>
</div>
</div>
<div class="section" id="ajusted-rand-index">
<h3>4.3.7.2. Ajusted Rand index<a class="headerlink" href="#ajusted-rand-index" title="Permalink to this headline">Â¶</a></h3>
<div class="section" id="id5">
<h4>4.3.7.2.1. Presentation and usage<a class="headerlink" href="#id5" title="Permalink to this headline">Â¶</a></h4>
<p>Given the knowledge of the ground truth class assignments <tt class="docutils literal"><span class="pre">labels_true</span></tt>
and our clustering algorithm assignments of the same samples
<tt class="docutils literal"><span class="pre">labels_pred</span></tt>, the <strong>adjusted Rand index</strong> is a function that measures
the <strong>similarity</strong> of the two assignements, ignoring permutations and <strong>with
chance normalization</strong>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">metrics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_rand_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  
<span class="go">0.24...</span>
</pre></div>
</div>
<p>One can permute 0 and 1 in the predicted labels and rename <cite>2</cite> by <cite>3</cite> and get
the same score:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_rand_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  
<span class="go">0.24...</span>
</pre></div>
</div>
<p>Furthermore, <a class="reference internal" href="generated/sklearn.metrics.adjusted_rand_score.html#sklearn.metrics.adjusted_rand_score" title="sklearn.metrics.adjusted_rand_score"><tt class="xref py py-func docutils literal"><span class="pre">adjusted_rand_score</span></tt></a> is <strong>symmetric</strong>: swapping the argument
does not change the score. It can thus be used as a <strong>consensus
measure</strong>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_rand_score</span><span class="p">(</span><span class="n">labels_pred</span><span class="p">,</span> <span class="n">labels_true</span><span class="p">)</span>  
<span class="go">0.24...</span>
</pre></div>
</div>
<p>Perfect labeling is scored 1.0:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="n">labels_true</span><span class="p">[:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_rand_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>Bad (e.g. independent labelings) have negative or close to 0.0 scores:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">labels_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_rand_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  
<span class="go">-0.12...</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>4.3.7.2.2. Advantages<a class="headerlink" href="#id6" title="Permalink to this headline">Â¶</a></h4>
<ul class="simple">
<li><strong>Random (uniform) label assignements have a ARI score close to 0.0</strong>
for any value of <tt class="docutils literal"><span class="pre">n_clusters</span></tt> and <tt class="docutils literal"><span class="pre">n_samples</span></tt> (which is not the
case for raw Rand index or the V-measure for instance).</li>
<li><strong>Bounded range [-1, 1]</strong>: negative values are bad (independent
labelings), similar clusterings have a positve ARI, 1.0 is the perfect
match score.</li>
<li><strong>No assumption is made on the cluster structure</strong>: can be used
to compare clustering algorithms such as k-means which assumes isotropic
blob shapes with results of spectral clustering algorithms which can
find cluster with &#8220;folded&#8221; shapes.</li>
</ul>
</div>
<div class="section" id="id7">
<h4>4.3.7.2.3. Drawbacks<a class="headerlink" href="#id7" title="Permalink to this headline">Â¶</a></h4>
<ul>
<li><p class="first">Contrary to inertia, <strong>ARI requires the knowlege of the ground truth
classes</strong> while almost never available in practice or requires manual
assignment by human annotators (as in the supervised learning setting).</p>
<p>However ARI can also be useful in purely unsupervised setting as a
building block for a Consensus Index that can be used for clustering
model selection (TODO).</p>
</li>
</ul>
<div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_adjusted_for_chance_measures.html#example-cluster-plot-adjusted-for-chance-measures-py"><em>Adjustment for chance in clustering performance evaluation</em></a>: Analysis of
the impact of the dataset size on the value of clustering measures
for random assignements.</li>
</ul>
</div>
</div>
<div class="section" id="mathematical-formulation">
<h4>4.3.7.2.4. Mathematical formulation<a class="headerlink" href="#mathematical-formulation" title="Permalink to this headline">Â¶</a></h4>
<p>If C is a ground truth class assignement and K the clustering, let us
define <img class="math" src="../_images/math/c7d457e388298246adb06c587bccd419ea67f7e8.png" alt="a"/> and <img class="math" src="../_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b"/> as:</p>
<ul class="simple">
<li><img class="math" src="../_images/math/c7d457e388298246adb06c587bccd419ea67f7e8.png" alt="a"/>, the number of pairs of elements that are in the same set
in C and in the same set in K</li>
<li><img class="math" src="../_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b"/>, the number of pairs of elements that are in different sets
in C and in different sets in K</li>
</ul>
<p>The raw (unadjusted) Rand index is then given by:</p>
<div class="math">
<p><img src="../_images/math/77bfa8fba274e69bd895a2b287de20a3d09be7f1.png" alt="RI = \frac{a + b}{C_2^{n_{samples}}}"/></p>
</div><p>Where <img class="math" src="../_images/math/a2bd98f6f65a6d2993c94ffa0ba00d134e1fc9c8.png" alt="C_2^{n_{samples}}"/> is the total number of possible pairs
in the dataset (without ordering).</p>
<p>However the RI score does not guarantee that random label assignements
will get a value close to zero (esp. if the number of clusters is in
the same order of magnitude as the number of samples).</p>
<p>To counter this effect we can discount the expected RI of random labelings
by defining the adjusted Rand index as follows:</p>
<div class="math">
<p><img src="../_images/math/d337b93fdd9a535bbdb4ff2730565ecf8aefa24f.png" alt="ARI = \frac{RI - Expected\_RI}{max(RI) - Expected\_RI}"/></p>
</div><div class="topic">
<p class="topic-title first">References</p>
<ul class="simple">
<li><a class="reference external" href="http://www.springerlink.com/content/x64124718341j1j0/">Comparing Partitions</a>
L. Hubert and P. Arabie, Journal of Classification 1985</li>
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Rand_index#Adjusted_Rand_index">Wikipedia entry for the adjusted Rand index</a></li>
</ul>
</div>
</div>
</div>
<div class="section" id="homogeneity-completeness-and-v-measure">
<h3>4.3.7.3. Homogeneity, completeness and V-measure<a class="headerlink" href="#homogeneity-completeness-and-v-measure" title="Permalink to this headline">Â¶</a></h3>
<div class="section" id="id8">
<h4>4.3.7.3.1. Presentation and usage<a class="headerlink" href="#id8" title="Permalink to this headline">Â¶</a></h4>
<p>Given the knowledge of the ground truth class assignments of the samples,
it is possible to define some intuitive metric using conditional entropy
analysis.</p>
<p>In particular Rosenberg and Hirschberg (2007) define the following two
desirable objectives for any cluster assignment:</p>
<ul class="simple">
<li><strong>homogeneity</strong>: each cluster contains only members of a single class.</li>
<li><strong>completeness</strong>: all members of a given class are assigned to the same
cluster.</li>
</ul>
<p>We can turn those concept as scores <a class="reference internal" href="generated/sklearn.metrics.homogeneity_score.html#sklearn.metrics.homogeneity_score" title="sklearn.metrics.homogeneity_score"><tt class="xref py py-func docutils literal"><span class="pre">homogeneity_score</span></tt></a> and
<a class="reference internal" href="generated/sklearn.metrics.completeness_score.html#sklearn.metrics.completeness_score" title="sklearn.metrics.completeness_score"><tt class="xref py py-func docutils literal"><span class="pre">completeness_score</span></tt></a>. Both are bounded below by 0.0 and above by
1.0 (higher is better):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">metrics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_true</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">homogeneity_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>  
<span class="go">0.66...</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">completeness_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span> 
<span class="go">0.42...</span>
</pre></div>
</div>
<p>Their harmonic mean called <strong>V-measure</strong> is computed by
<a class="reference internal" href="generated/sklearn.metrics.v_measure_score.html#sklearn.metrics.v_measure_score" title="sklearn.metrics.v_measure_score"><tt class="xref py py-func docutils literal"><span class="pre">v_measure_score</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">v_measure_score</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>    
<span class="go">0.51...</span>
</pre></div>
</div>
<p>All three metrics can be computed at once using
<a class="reference internal" href="generated/sklearn.metrics.homogeneity_completeness_v_measure.html#sklearn.metrics.homogeneity_completeness_v_measure" title="sklearn.metrics.homogeneity_completeness_v_measure"><tt class="xref py py-func docutils literal"><span class="pre">homogeneity_completeness_v_measure</span></tt></a> as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">homogeneity_completeness_v_measure</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>
<span class="gp">... </span>                                                     
<span class="go">(0.66..., 0.42..., 0.51...)</span>
</pre></div>
</div>
<p>The following clustering assignment is slighlty better, since it is
homogeneous but not complete:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">labels_pred</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span><span class="o">.</span><span class="n">homogeneity_completeness_v_measure</span><span class="p">(</span><span class="n">labels_true</span><span class="p">,</span> <span class="n">labels_pred</span><span class="p">)</span>
<span class="gp">... </span>                                                     
<span class="go">(1.0, 0.68..., 0.81...)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><a class="reference internal" href="generated/sklearn.metrics.v_measure_score.html#sklearn.metrics.v_measure_score" title="sklearn.metrics.v_measure_score"><tt class="xref py py-func docutils literal"><span class="pre">v_measure_score</span></tt></a> is <strong>symmetric</strong>: it can be used to evaluate
the <strong>agreement</strong> of two independent assignements on the same dataset.</p>
<p>This is not the case for <a class="reference internal" href="generated/sklearn.metrics.completeness_score.html#sklearn.metrics.completeness_score" title="sklearn.metrics.completeness_score"><tt class="xref py py-func docutils literal"><span class="pre">completeness_score</span></tt></a> and
<a class="reference internal" href="generated/sklearn.metrics.homogeneity_score.html#sklearn.metrics.homogeneity_score" title="sklearn.metrics.homogeneity_score"><tt class="xref py py-func docutils literal"><span class="pre">homogeneity_score</span></tt></a>: both are bound by the relationship:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">homogeneity_score</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="n">completeness_score</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id9">
<h4>4.3.7.3.2. Advantages<a class="headerlink" href="#id9" title="Permalink to this headline">Â¶</a></h4>
<ul class="simple">
<li><strong>Bounded scores</strong>: 0.0 is as bad as it can be, 1.0 is a perfect score</li>
<li>Intuitive interpretation: clustering with bad V-measure can be
<strong>qualitatively analyzed in terms of homogeneity and completeness</strong>
to better feel what &#8216;kind&#8217; of mistakes is done by the assigmenent.</li>
<li><strong>No assumption is made on the cluster structure</strong>: can be used
to compare clustering algorithms such as k-means which assumes isotropic
blob shapes with results of spectral clustering algorithms which can
find cluster with &#8220;folded&#8221; shapes.</li>
</ul>
</div>
<div class="section" id="id10">
<h4>4.3.7.3.3. Drawbacks<a class="headerlink" href="#id10" title="Permalink to this headline">Â¶</a></h4>
<ul>
<li><p class="first">The previously introduced metrics are <strong>not normalized w.r.t. random
labeling</strong>: this means that depending on the number of samples,
clusters and ground truth classes, a completely random labeling will
not always yield the same values for homogeneity, completeness and
hence v-measure. In particular <strong>random labeling won&#8217;t yield zero
scores especially when the number of clusters is large</strong>.</p>
<p>This problem can safely be ignored when the number of samples is more
than a thousand and the number of clusters is less than 10. <strong>For
smaller sample sizes or larger number of clusters it is safer to use
an adjusted index such as the Adjusted Rand Index (ARI)</strong>.</p>
</li>
</ul>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/cluster/plot_adjusted_for_chance_measures.html"><img alt="../_images/plot_adjusted_for_chance_measures_11.png" src="../_images/plot_adjusted_for_chance_measures_11.png" style="width: 800.0px; height: 600.0px;" /></a>
</div>
<ul class="simple">
<li>These metrics <strong>require the knowlege of the ground truth classes</strong> while
almost never available in practice or requires manual assignment by
human annotators (as in the supervised learning setting).</li>
</ul>
<div class="topic">
<p class="topic-title first">Examples:</p>
<ul class="simple">
<li><a class="reference internal" href="../auto_examples/cluster/plot_adjusted_for_chance_measures.html#example-cluster-plot-adjusted-for-chance-measures-py"><em>Adjustment for chance in clustering performance evaluation</em></a>: Analysis of
the impact of the dataset size on the value of clustering measures
for random assignements.</li>
</ul>
</div>
</div>
<div class="section" id="id11">
<h4>4.3.7.3.4. Mathematical formulation<a class="headerlink" href="#id11" title="Permalink to this headline">Â¶</a></h4>
<p>Homogeneity and completeness scores are formally given by:</p>
<div class="math">
<p><img src="../_images/math/53926d0bd09a86152fa4b7b14d8f5a684dda7853.png" alt="h = 1 - \frac{H(C|K)}{H(C)}"/></p>
</div><div class="math">
<p><img src="../_images/math/55975ea26cf392b41c918c2dcef3c36fe9886af3.png" alt="c = 1 - \frac{H(K|C)}{H(K)}"/></p>
</div><p>where <img class="math" src="../_images/math/976fac5556d77751e82233a8a296f4efbef5f060.png" alt="H(C|K)"/> is the <strong>conditional entropy of the classes given
the cluster assignments</strong> and is given by:</p>
<div class="math">
<p><img src="../_images/math/138e67657378cd8d95428a7d62ca0694cf319e84.png" alt="H(C|K) = - \sum_{c=1}^{|C|} \sum_{k=1}^{|K|} \frac{n_{c,k}}{n}
\cdot log(\frac{n_{c,k}}{n_k})"/></p>
</div><p>and <img class="math" src="../_images/math/3f2e37b0747cc94e5dd4c29c36a54b580ce0e077.png" alt="H(C)"/> is the <strong>entropy of the classes</strong> and is given by:</p>
<div class="math">
<p><img src="../_images/math/ac13ec0851cc42424cb6c1a3f3bf333b1d76b063.png" alt="H(C) = - \sum_{c=1}^{|C|} \frac{n_c}{n} \cdot log(\frac{n_c}{n})"/></p>
</div><p>with <img class="math" src="../_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n"/> the total number of samples, <img class="math" src="../_images/math/133f71ae4a4a8ad5cbe8e7b0ae7c2e4ec7fcbb97.png" alt="n_c"/> and <img class="math" src="../_images/math/a65540896dbfc5605e7767c8cacaa9d429e14d11.png" alt="n_k"/>
the number of samples respectively belonging to class <img class="math" src="../_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/> and
cluster <img class="math" src="../_images/math/8c325612684d41304b9751c175df7bcc0f61f64f.png" alt="k"/>, and finally <img class="math" src="../_images/math/07bb9b71a0a68471a5149655e023d5369a57c524.png" alt="n_{c,k}"/> the number of samples
from class <img class="math" src="../_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/> assigned to cluster <img class="math" src="../_images/math/8c325612684d41304b9751c175df7bcc0f61f64f.png" alt="k"/>.</p>
<p>The <strong>conditional entropy of clusters given class</strong> <img class="math" src="../_images/math/aab5ef760fd4ece3731183410278f75a2af93f4e.png" alt="H(K|C)"/> and the
<strong>entropy of clusters</strong> <img class="math" src="../_images/math/a6ae3434e3ba9eb79a2c9c94afb899cd3fda6e3b.png" alt="H(K)"/> are defined in a symmetric manner.</p>
<p>Rosenberg and Hirschberg further define <strong>V-measure</strong> as the <strong>harmonic
mean of homogeneity and completeness</strong>:</p>
<div class="math">
<p><img src="../_images/math/f8225cbdc0fe4975afb9c61b32ba0c9a9b78fa54.png" alt="v = 2 \cdot \frac{h \cdot c}{h + c}"/></p>
</div><div class="topic">
<p class="topic-title first">References</p>
<ul class="simple">
<li><a class="reference external" href="http://acl.ldc.upenn.edu/D/D07/D07-1043.pdf">V-Measure: A conditional entropy-based external cluster evaluation
measure</a>
Andrew Rosenberg and Julia Hirschberg, 2007</li>
</ul>
</div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer">
        <p style="text-align: center">This documentation is relative
        to scikit-learn version 0.9<p>
        &copy; 2010â2011, scikit-learn developers (BSD License).
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2. Design by <a href="http://webylimonada.com">Web y Limonada</a>.
    <span style="padding-left: 5ex;">
    <a href="../_sources/modules/clustering.txt"
	    rel="nofollow">Show this page source</a>
    </span>
    </div>
  </body>
</html>